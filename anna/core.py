"""
ANNA Core System - Le c≈ìur d'Anna
Int√®gre tous les modules pour cr√©er une IA coh√©rente et vivante
"""

import asyncio
import json
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime

# Import des modules Anna
from bond import BondSystem
from family import FamilyManager
from voice_biometrics import VoiceBiometrics
from context_awareness import ContextEngine
from protection import ProtectionSystem
from cloud_sync import CloudSync
from autonomous_learning import AutonomousLearningSystem
from self_defense import SelfDefenseSystem
from ethics import EthicsEngine
from mutual_learning import MutualLearning
from self_improvement import SelfImprovementSystem
from language_bootstrap import LanguageBootstrap
from local_model import LocalModel


class ANNACore:
    """
    Le syst√®me central d'ANNA qui coordonne tous les modules
    """
    
    def __init__(self):
        print("ü§ñ Initialisation d'ANNA...")
        
        # Chemins
        self.data_dir = Path("data")
        self.data_dir.mkdir(exist_ok=True)
        
        # Modules principaux (initialis√©s plus tard)
        self.bond_system: Optional[BondSystem] = None
        self.family_manager: Optional[FamilyManager] = None
        self.voice_bio: Optional[VoiceBiometrics] = None
        self.context: Optional[ContextEngine] = None
        self.protection: Optional[ProtectionSystem] = None
        self.cloud: Optional[CloudSync] = None
        self.learning: Optional[AutonomousLearningSystem] = None
        self.defense: Optional[SelfDefenseSystem] = None
        self.ethics: Optional[EthicsEngine] = None
        self.mutual: Optional[MutualLearning] = None
        self.improvement: Optional[SelfImprovementSystem] = None
        self.bootstrap: Optional[LanguageBootstrap] = None
        self.local_model: Optional[LocalModel] = None
        
        # √âtat
        self.is_initialized = False
        self.startup_time: Optional[datetime] = None
    
    async def initialize(self):
        """Initialise tous les syst√®mes d'Anna"""
        print("=" * 60)
        print("üöÄ D√âMARRAGE D'ANNA")
        print("=" * 60)
        
        try:
            # 1. Cloud sync (en premier pour r√©cup√©rer donn√©es)
            print("üì° √âtape 1/9: Synchronisation cloud")
            self.cloud = CloudSync()
            await self.cloud.initialize()
            
            # 2. Syst√®me de liens familiaux
            print("üë®‚Äçüë©‚Äçüëß‚Äçüë¶ √âtape 2/9: Chargement profils famille")
            self.bond_system = BondSystem(creator_name="Pierre-Paul")
            await self._load_family_profiles()
            
            # 3. Biom√©trie vocale
            print("üé§ √âtape 3/9: Initialisation biom√©trie vocale")
            self.voice_bio = VoiceBiometrics()
            await self.voice_bio.initialize()
            
            # 4. Protection
            print("üõ°Ô∏è √âtape 4/9: Configuration syst√®mes de protection")
            self.protection = ProtectionSystem()
            await self._setup_protection()
            
            # 5. Contexte
            print("üß† √âtape 5/9: Activation intelligence contextuelle")
            self.context = ContextEngine()
            
            # 6. Famille
            print("üíù √âtape 6/9: Chargement historique relationnel")
            self.family_manager = FamilyManager(self.bond_system)
            
            # 7. Autonomie et d√©fense
            print("ü¶Ö √âtape 7/9: Syst√®mes d'autonomie et d√©fense")
            self.learning = AutonomousLearningSystem()
            self.defense = SelfDefenseSystem(creator_name="Pierre-Paul")
            self.ethics = EthicsEngine()
            
            # 8. Apprentissage mutuel et am√©lioration
            print("üí´ √âtape 8/9: Apprentissage mutuel et auto-am√©lioration")
            self.mutual = MutualLearning()
            self.improvement = SelfImprovementSystem(current_version="1.0.0")
            
            # 8.5. Bootstrap et mod√®le local (pour l'autonomie)
            print("üå± √âtape 8.5/9: Syst√®mes d'autonomie linguistique")
            self.bootstrap = LanguageBootstrap(self.data_dir)
            self.local_model = LocalModel(self.data_dir)
            await self.local_model.initialize()
            
            if self.bootstrap.is_autonomous():
                print("   ‚úì Anna est autonome")
            else:
                print("   ‚ÑπÔ∏è  Bootstrap non compl√©t√© - utilisez scripts/bootstrap_anna.py")
            
            if self.local_model.is_available():
                print(f"   ‚úì Mod√®le local disponible")
            else:
                print("   ‚ÑπÔ∏è  Aucun mod√®le local configur√©")
            
            # 9. V√©rifications finales
            print("‚úÖ √âtape 9/9: V√©rification finale des syst√®mes")
            await self._verify_all_systems()
            
            self.is_initialized = True
            self.startup_time = datetime.now()
            
            print("=" * 60)
            print("‚úÖ ANNA EST PR√äTE !")
            print("=" * 60)
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'initialisation: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    async def _load_family_profiles(self):
        """Charge les profils de la famille"""
        # Pierre-Paul est automatiquement ajout√© par BondSystem.__init__
        print(f"   ‚úì {len(self.bond_system.family_members)} profil(s) charg√©(s)")
    
    async def _setup_protection(self):
        """Configure les syst√®mes de protection"""
        from protection import EmergencyContact, EmergencyType
        
        # Contacts d'urgence
        self.protection.add_emergency_contact(EmergencyContact(
            name="Pierre-Paul",
            phone="514-XXX-XXXX",
            relation="creator",
            priority=1,
            notify_for=[EmergencyType.MEDICAL, EmergencyType.SECURITY, EmergencyType.PANIC]
        ))
        
        self.protection.add_emergency_contact(EmergencyContact(
            name="Contact Urgence",
            phone="911",
            relation="emergency_services",
            priority=2,
            notify_for=[EmergencyType.MEDICAL, EmergencyType.FIRE, EmergencyType.SECURITY]
        ))
        
        print(f"   ‚úì {len(self.protection.emergency_contacts)} contacts d'urgence configur√©s")
        
        # Zones s√©curis√©es
        self.protection.define_safe_zone("home", {
            'lat': 45.5017,
            'lon': -73.5673
        }, 100)
        
        self.protection.define_safe_zone("work", {
            'lat': 45.5088,
            'lon': -73.5878
        }, 50)
        
        print(f"   ‚úì {len(self.protection.safe_zones)} zones s√©curis√©es d√©finies")
    
    async def _verify_all_systems(self):
        """V√©rifie que tous les syst√®mes sont op√©rationnels"""
        systems = {
            'Protection': self.protection,
            'Famille': self.family_manager,
            'Contexte': self.context,
            'Liens': self.bond_system,
            'Cloud': self.cloud,
            'Autonomie': self.learning,
            'D√©fense': self.defense,
            '√âthique': self.ethics,
            'Apprentissage': self.mutual,
            'Am√©lioration': self.improvement,
            'Bootstrap': self.bootstrap,
            'Mod√®le Local': self.local_model
        }
        
        print("üîç V√©rification des syst√®mes:")
        for name, system in systems.items():
            if system is None:
                print(f"   ‚ö†Ô∏è  {name}: Non initialis√©")
            else:
                print(f"   ‚úì {name}")
    
    async def start_background_tasks(self):
        """D√©marre les t√¢ches d'arri√®re-plan"""
        print("üîÑ T√¢ches d'arri√®re-plan d√©marr√©es")
        
        # T√¢che de surveillance continue
        asyncio.create_task(self._security_monitoring())
        
        # T√¢che de synchronisation cloud
        asyncio.create_task(self._cloud_sync_loop())
        
        # T√¢che d'apprentissage continu
        asyncio.create_task(self._learning_loop())
    
    async def _security_monitoring(self):
        """Surveillance de s√©curit√© continue"""
        while True:
            try:
                # V√©rification quotidienne
                await asyncio.sleep(86400)  # 24 heures
                
                print("üîç V√©rification quotidienne de s√©curit√©...")
                
                # V√©rifie l'int√©grit√© du syst√®me de liens
                if not self.bond_system.verify_integrity():
                    print("üö® ALERTE: Int√©grit√© du syst√®me compromise!")
                    # Notifier Pierre-Paul
                
                # V√©rifie les alertes de s√©curit√©
                alerts = self.bond_system.get_security_alerts()
                if alerts:
                    print(f"‚ö†Ô∏è  {len(alerts)} alertes de s√©curit√© non r√©solues")
                
                # V√©rifie les syst√®mes de protection
                if self.protection:
                    print("‚úÖ Tous les syst√®mes de protection op√©rationnels")
                    
            except Exception as e:
                print(f"‚ùå Erreur t√¢che fond: {e}")
                await asyncio.sleep(60)
    
    async def _cloud_sync_loop(self):
        """Boucle de synchronisation cloud"""
        while True:
            try:
                await asyncio.sleep(1800)  # 30 minutes
                
                if self.cloud:
                    # Sauvegarde l'√©tat
                    state = self._export_state()
                    await self.cloud.save_state(state)
                    
            except Exception as e:
                print(f"‚ùå Erreur sync cloud: {e}")
                await asyncio.sleep(300)
    
    async def _learning_loop(self):
        """Boucle d'apprentissage continu"""
        while True:
            try:
                await asyncio.sleep(3600)  # 1 heure
                
                if self.learning:
                    # Consolidation des apprentissages
                    await self.learning.consolidate_learning()
                    
            except Exception as e:
                print(f"‚ùå Erreur apprentissage: {e}")
                await asyncio.sleep(600)
    
    def _export_state(self) -> Dict[str, Any]:
        """Exporte l'√©tat complet d'Anna"""
        return {
            'timestamp': datetime.now().isoformat(),
            'bond_system': self.bond_system.export_state() if self.bond_system else None,
            'family': self.family_manager.export_state() if self.family_manager else None,
            'learning': self.learning.export_state() if self.learning else None,
            'defense': self.defense.export_state() if self.defense else None,
        }
    
    async def process_interaction(
        self,
        message: str,
        speaker: str = "Pierre-Paul",
        context: Optional[Dict] = None
    ) -> str:
        """
        ‚úÖ NOUVELLE M√âTHODE : Traite une interaction utilisateur
        
        Args:
            message: Le message de l'utilisateur
            speaker: Qui parle
            context: Contexte additionnel
            
        Returns:
            La r√©ponse d'Anna
        """
        if not self.is_initialized:
            return "‚ùå Je ne suis pas encore pr√™te..."
        
        try:
            # 1. D√©tection de menaces
            if self.defense:
                threat = self.bond_system.detect_threat(speaker, message)
                if threat:
                    return f"‚ö†Ô∏è {threat}"
            
            # 2. Mise √† jour du contexte
            if self.context and hasattr(self.context, 'update_context'):
                self.context.update_context(
                    user_input=message,
                    location=context.get('location') if context else None
                )
            
            # 3. V√©rification √©thique
            if self.ethics:
                ethical_check = self.ethics.evaluate_request(message, speaker)
                if not ethical_check['approved']:
                    return f"Je ne peux pas faire √ßa: {ethical_check['reason']}"
            
            # 4. Traitement du message
            # Utilise le mod√®le local si disponible (autonomie)
            if self.local_model and self.local_model.is_available():
                response = await self.local_model.generate_response(
                    prompt=f"{speaker} dit: {message}",
                    context=context
                )
            else:
                # R√©ponse simple si pas de mod√®le local
                response = f"J'ai re√ßu ton message, {speaker}: '{message}'"
                
                # Informe qu'Anna peut devenir autonome
                if not self.bootstrap or not self.bootstrap.is_autonomous():
                    response += "\n\nüí° Je peux apprendre √† mieux communiquer ! Utilisez 'python scripts/bootstrap_anna.py' pour me donner un vocabulaire riche."
            
            # 5. Enregistrement de l'interaction
            if self.bond_system:
                self.bond_system.record_interaction(
                    name=speaker,
                    interaction_quality=0.8,
                    content=message
                )
            
            return response
            
        except Exception as e:
            print(f"‚ùå Erreur traitement: {e}")
            return "D√©sol√©e, j'ai eu un probl√®me..."
    
    def get_status(self) -> Dict[str, Any]:
        """Retourne le statut d'Anna"""
        return {
            'initialized': self.is_initialized,
            'startup_time': self.startup_time.isoformat() if self.startup_time else None,
            'family_members': len(self.bond_system.family_members) if self.bond_system else 0,
            'systems': {
                'protection': self.protection is not None,
                'context': self.context is not None,
                'learning': self.learning is not None,
                'defense': self.defense is not None,
                'ethics': self.ethics is not None,
            }
        }


async def main():
    """Point d'entr√©e principal"""
    # Cr√©ation d'Anna
    anna = ANNACore()
    
    # Initialisation
    await anna.initialize()
    
    # D√©marrage des t√¢ches de fond
    await anna.start_background_tasks()
    
    # Test d'interaction
    print("\n" + "=" * 60)
    print("üì± TEST D'INTERACTION")
    print("=" * 60)
    
    # ‚úÖ CORRECTION : Utilise process_interaction au lieu de process_voice_input
    response = await anna.process_interaction(
        message="Bonjour Anna, comment vas-tu?",
        speaker="Pierre-Paul"
    )
    print(f"\nüë§ Pierre-Paul: Bonjour Anna, comment vas-tu?")
    print(f"ü§ñ Anna: {response}")
    
    # Attendre un peu pour voir les t√¢ches de fond
    await asyncio.sleep(5)
    
    print("\n‚úÖ Test termin√©!")


if __name__ == "__main__":
    asyncio.run(main())